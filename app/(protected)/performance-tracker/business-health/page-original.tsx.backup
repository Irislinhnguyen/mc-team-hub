'use client'

import { useState, useEffect, useRef, useCallback, useMemo } from 'react'
import { FilterPanel } from '../../../components/analytics/FilterPanel'
import { MetricCard } from '../../../components/analytics/MetricCard'
import { TimeSeriesChart } from '../../../components/analytics/TimeSeriesChart'
import { BarChartComponent } from '../../../components/analytics/BarChart'
import { DataTable } from '../../../components/analytics/DataTable'
import { LazyDataTable } from '../../../components/analytics/LazyDataTable'
import { PageHeader } from '../../../components/analytics/PageHeader'
import { CrossFilterChips } from '../../../components/analytics/CrossFilterChips'
import FilterPanelSkeleton from '../../../components/analytics/skeletons/FilterPanelSkeleton'
import MetricCardSkeleton from '../../../components/analytics/skeletons/MetricCardSkeleton'
import ChartSkeleton from '../../../components/analytics/skeletons/ChartSkeleton'
import TableSkeleton from '../../../components/analytics/skeletons/TableSkeleton'
import { colors } from '../../../../lib/colors'
import { useCrossFilter } from '../../../contexts/CrossFilterContext'
import { ToggleGroup, ToggleGroupItem } from '../../../../src/components/ui/toggle-group'

interface FilterConfig {
  name: string
  label: string
  type: 'daterange' | 'select'
  options?: Array<{ label: string; value: string }>
}

interface MetadataOptions {
  pics: Array<{ label: string; value: string }>
  products: Array<{ label: string; value: string }>
  pids: Array<{ label: string; value: string }>
  mids: Array<{ label: string; value: string }>
  pubnames: Array<{ label: string; value: string }>
  medianames: Array<{ label: string; value: string }>
  zids: Array<{ label: string; value: string }>
  zonenames: Array<{ label: string; value: string }>
  teams: Array<{ label: string; value: string }>
}

export default function BusinessHealthPage() {
  const contentRef = useRef<HTMLDivElement>(null)
  const [data, setData] = useState<any>(null)
  const [loading, setLoading] = useState(false)
  const [currentFilters, setCurrentFilters] = useState<Record<string, any>>({})
  const [metadata, setMetadata] = useState<MetadataOptions | null>(null)
  const [metadataLoading, setMetadataLoading] = useState(true)
  const [metadataError, setMetadataError] = useState<string | null>(null)
  const { crossFilters } = useCrossFilter()
  const prevCrossFilterFieldsRef = useRef<string[]>([])
  const [selectedMetric, setSelectedMetric] = useState<'revenue' | 'profit' | 'requests' | 'paid' | 'ecpm' | 'fill_rate'>('revenue')

  // Lazy loading state for large tables
  const [zoneMonitoringData, setZoneMonitoringData] = useState<any[]>([])
  const [zoneMonitoringTotal, setZoneMonitoringTotal] = useState(0)
  const [zoneMonitoringLoading, setZoneMonitoringLoading] = useState(false)
  const [zoneMonitoringOffset, setZoneMonitoringOffset] = useState(0)

  const [listOfPidData, setListOfPidData] = useState<any[]>([])
  const [listOfPidTotal, setListOfPidTotal] = useState(0)
  const [listOfPidLoading, setListOfPidLoading] = useState(false)
  const [listOfPidOffset, setListOfPidOffset] = useState(0)

  const [listOfPidByDateData, setListOfPidByDateData] = useState<any[]>([])
  const [listOfPidByDateTotal, setListOfPidByDateTotal] = useState(0)
  const [listOfPidByDateLoading, setListOfPidByDateLoading] = useState(false)
  const [listOfPidByDateOffset, setListOfPidByDateOffset] = useState(0)

  const [listOfMidData, setListOfMidData] = useState<any[]>([])
  const [listOfMidTotal, setListOfMidTotal] = useState(0)
  const [listOfMidLoading, setListOfMidLoading] = useState(false)
  const [listOfMidOffset, setListOfMidOffset] = useState(0)

  const [listOfMidByDateData, setListOfMidByDateData] = useState<any[]>([])
  const [listOfMidByDateTotal, setListOfMidByDateTotal] = useState(0)
  const [listOfMidByDateLoading, setListOfMidByDateLoading] = useState(false)
  const [listOfMidByDateOffset, setListOfMidByDateOffset] = useState(0)

  // Load metadata and initial data in parallel
  useEffect(() => {
    const today = new Date()
    const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000)
    const defaultFilters = {
      startDate: thirtyDaysAgo.toISOString().split('T')[0],
      endDate: today.toISOString().split('T')[0],
    }

    // Start both requests in parallel
    const fetchMetadata = async () => {
      try {
        const response = await fetch('/api/analytics/metadata')
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: Failed to fetch metadata`)
        }
        const result = await response.json()
        if (result.status === 'ok') {
          setMetadata(result.data)
          setMetadataError(null)
        } else {
          throw new Error(result.message || 'Unknown error fetching metadata')
        }
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : 'Failed to load filters'
        console.error('Error fetching metadata:', errorMessage)
        setMetadataError(errorMessage)
        setMetadata(null)
      } finally {
        setMetadataLoading(false)
      }
    }

    // Fetch initial data immediately
    setCurrentFilters(defaultFilters)
    fetchMetadata()
  }, [])

  // Apply cross-filters to current filters whenever they change
  useEffect(() => {
    setCurrentFilters(prev => {
      // Remove old cross-filter keys
      const cleaned = { ...prev }
      prevCrossFilterFieldsRef.current.forEach(field => {
        delete cleaned[field]
      })

      // Apply new cross-filters
      const newCrossFilterValues = crossFilters.reduce((acc, filter) => {
        acc[filter.field] = filter.value
        return acc
      }, {} as Record<string, any>)

      // Update ref with current fields
      prevCrossFilterFieldsRef.current = crossFilters.map(f => f.field)

      // Merge cleaned filters with new cross-filters
      return { ...cleaned, ...newCrossFilterValues }
    })
  }, [crossFilters])

  // Fetch data when filters change
  useEffect(() => {
    if (Object.keys(currentFilters).length > 0) {
      // Reset lazy loading state
      setZoneMonitoringData([])
      setZoneMonitoringOffset(0)
      setListOfPidData([])
      setListOfPidOffset(0)
      setListOfPidByDateData([])
      setListOfPidByDateOffset(0)
      setListOfMidData([])
      setListOfMidOffset(0)
      setListOfMidByDateData([])
      setListOfMidByDateOffset(0)

      fetchData()
    }
  }, [currentFilters])

  // Phase 1: Fetch metrics and charts (fast queries)
  const fetchData = async () => {
    setLoading(true)
    try {
      const response = await fetch('/api/analytics/business-health-filtered', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(currentFilters),
      })

      if (!response.ok) throw new Error('Failed to fetch data')
      const result = await response.json()
      setData(result.data)

      // Phase 2: Start loading large tables after main data loads
      setTimeout(() => {
        loadZoneMonitoringBatch(0)
        loadListOfPidBatch(0)
        loadListOfPidByDateBatch(0)
        loadListOfMidBatch(0)
        loadListOfMidByDateBatch(0)
      }, 100)
    } catch (error) {
      console.error('Error:', error)
    } finally {
      setLoading(false)
    }
  }

  // Lazy loading functions for zone monitoring
  const loadZoneMonitoringBatch = useCallback(async (offset: number) => {
    setZoneMonitoringLoading(true)
    try {
      const response = await fetch('/api/analytics/business-health-paginated', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          filters: currentFilters,
          queryType: 'zoneMonitoringTimeSeries',
          offset,
          limit: 500
        }),
      })

      if (!response.ok) throw new Error('Failed to fetch zone monitoring data')
      const result = await response.json()

      if (result.status === 'success') {
        setZoneMonitoringData(prev => offset === 0 ? result.data.rows : [...prev, ...result.data.rows])
        setZoneMonitoringTotal(result.data.totalCount)
        setZoneMonitoringOffset(offset + result.data.rows.length)
      }
    } catch (error) {
      console.error('Error loading zone monitoring:', error)
    } finally {
      setZoneMonitoringLoading(false)
    }
  }, [currentFilters])

  const loadMoreZoneMonitoring = useCallback(async () => {
    if (zoneMonitoringOffset < zoneMonitoringTotal) {
      await loadZoneMonitoringBatch(zoneMonitoringOffset)
    }
  }, [zoneMonitoringOffset, zoneMonitoringTotal, loadZoneMonitoringBatch])

  // Lazy loading functions for list of PID
  const loadListOfPidBatch = useCallback(async (offset: number) => {
    setListOfPidLoading(true)
    try {
      const response = await fetch('/api/analytics/business-health-paginated', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          filters: currentFilters,
          queryType: 'listOfPid',
          offset,
          limit: 500
        }),
      })

      if (!response.ok) throw new Error('Failed to fetch list of PID data')
      const result = await response.json()

      if (result.status === 'success') {
        setListOfPidData(prev => offset === 0 ? result.data.rows : [...prev, ...result.data.rows])
        setListOfPidTotal(result.data.totalCount)
        setListOfPidOffset(offset + result.data.rows.length)
      }
    } catch (error) {
      console.error('Error loading list of PID:', error)
    } finally {
      setListOfPidLoading(false)
    }
  }, [currentFilters])

  const loadMoreListOfPid = useCallback(async () => {
    if (listOfPidOffset < listOfPidTotal) {
      await loadListOfPidBatch(listOfPidOffset)
    }
  }, [listOfPidOffset, listOfPidTotal, loadListOfPidBatch])

  // Lazy loading functions for list of PID by date
  const loadListOfPidByDateBatch = useCallback(async (offset: number) => {
    setListOfPidByDateLoading(true)
    try {
      const response = await fetch('/api/analytics/business-health-paginated', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          filters: currentFilters,
          queryType: 'listOfPidByDate',
          offset,
          limit: 500
        }),
      })

      if (!response.ok) throw new Error('Failed to fetch list of PID by date data')
      const result = await response.json()

      if (result.status === 'success') {
        setListOfPidByDateData(prev => offset === 0 ? result.data.rows : [...prev, ...result.data.rows])
        setListOfPidByDateTotal(result.data.totalCount)
        setListOfPidByDateOffset(offset + result.data.rows.length)
      }
    } catch (error) {
      console.error('Error loading list of PID by date:', error)
    } finally {
      setListOfPidByDateLoading(false)
    }
  }, [currentFilters])

  const loadMoreListOfPidByDate = useCallback(async () => {
    if (listOfPidByDateOffset < listOfPidByDateTotal) {
      await loadListOfPidByDateBatch(listOfPidByDateOffset)
    }
  }, [listOfPidByDateOffset, listOfPidByDateTotal, loadListOfPidByDateBatch])

  // Lazy loading functions for list of MID
  const loadListOfMidBatch = useCallback(async (offset: number) => {
    setListOfMidLoading(true)
    try {
      const response = await fetch('/api/analytics/business-health-paginated', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          filters: currentFilters,
          queryType: 'listOfMid',
          offset,
          limit: 500
        }),
      })

      if (!response.ok) throw new Error('Failed to fetch list of MID data')
      const result = await response.json()

      if (result.status === 'success') {
        setListOfMidData(prev => offset === 0 ? result.data.rows : [...prev, ...result.data.rows])
        setListOfMidTotal(result.data.totalCount)
        setListOfMidOffset(offset + result.data.rows.length)
      }
    } catch (error) {
      console.error('Error loading list of MID:', error)
    } finally {
      setListOfMidLoading(false)
    }
  }, [currentFilters])

  const loadMoreListOfMid = useCallback(async () => {
    if (listOfMidOffset < listOfMidTotal) {
      await loadListOfMidBatch(listOfMidOffset)
    }
  }, [listOfMidOffset, listOfMidTotal, loadListOfMidBatch])

  // Lazy loading functions for list of MID by date
  const loadListOfMidByDateBatch = useCallback(async (offset: number) => {
    setListOfMidByDateLoading(true)
    try {
      const response = await fetch('/api/analytics/business-health-paginated', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          filters: currentFilters,
          queryType: 'listOfMidByDate',
          offset,
          limit: 500
        }),
      })

      if (!response.ok) throw new Error('Failed to fetch list of MID by date data')
      const result = await response.json()

      if (result.status === 'success') {
        setListOfMidByDateData(prev => offset === 0 ? result.data.rows : [...prev, ...result.data.rows])
        setListOfMidByDateTotal(result.data.totalCount)
        setListOfMidByDateOffset(offset + result.data.rows.length)
      }
    } catch (error) {
      console.error('Error loading list of MID by date:', error)
    } finally {
      setListOfMidByDateLoading(false)
    }
  }, [currentFilters])

  const loadMoreListOfMidByDate = useCallback(async () => {
    if (listOfMidByDateOffset < listOfMidByDateTotal) {
      await loadListOfMidByDateBatch(listOfMidByDateOffset)
    }
  }, [listOfMidByDateOffset, listOfMidByDateTotal, loadListOfMidByDateBatch])

  // Show error state for metadata if it fails
  const showMetadataError = metadataError && !metadataLoading

  const filterConfig: FilterConfig[] = [
    {
      name: 'daterange',
      label: 'Select date',
      type: 'daterange',
    },
    {
      name: 'team',
      label: 'team',
      type: 'select',
      options: metadata?.teams || [],
    },
    {
      name: 'pic',
      label: 'pic',
      type: 'select',
      options: metadata?.pics || [],
    },
    {
      name: 'h5',
      label: 'h5',
      type: 'select',
      options: metadata?.products || [],
    },
    {
      name: 'product',
      label: 'product',
      type: 'select',
      options: metadata?.products || [],
    },
    {
      name: 'pid',
      label: 'pid',
      type: 'select',
      options: metadata?.pids || [],
    },
    {
      name: 'mid',
      label: 'mid',
      type: 'select',
      options: metadata?.mids || [],
    },
    {
      name: 'pubname',
      label: 'pubname',
      type: 'select',
      options: metadata?.pubnames || [],
    },
    {
      name: 'medianame',
      label: 'medianame',
      type: 'select',
      options: metadata?.medianames || [],
    },
    {
      name: 'zid',
      label: 'zid',
      type: 'select',
      options: metadata?.zids || [],
    },
    {
      name: 'zonename',
      label: 'zonename',
      type: 'select',
      options: metadata?.zonenames || [],
    },
  ]


  const metrics = data?.metrics || {}

  // Format time series data - preserve raw date for filtering (MEMOIZED)
  const timeSeries = useMemo(() => {
    return (data?.timeSeries || []).map((d: any) => {
      const rawDate = d.date.value || d.date
      return {
        date: new Date(rawDate).toLocaleDateString('en-US', { month: 'short', day: 'numeric' }),
        rawDate: rawDate, // Keep ISO format for cross-filtering
        revenue: parseFloat(d.revenue) || 0,
        profit: parseFloat(d.profit) || 0,
      }
    })
  }, [data?.timeSeries])

  // Format product trend data - group by product and date, preserve raw dates (MEMOIZED)
  const productTrendData = useMemo(() => {
    const productTrendRaw = data?.productTrend || []
    const productTrendMap = new Map<string, Record<string, any>>()
    productTrendRaw.forEach((d: any) => {
      const rawDate = d.date.value || d.date
      const dateStr = new Date(rawDate).toLocaleDateString('en-US', { month: 'short', day: 'numeric' })
      if (!productTrendMap.has(dateStr)) {
        productTrendMap.set(dateStr, { date: dateStr, rawDate: rawDate })
      }
      const row = productTrendMap.get(dateStr)!
      // Store all metrics for each product
      row[`${d.product}_profit`] = parseFloat(d.profit) || 0
      row[`${d.product}_revenue`] = parseFloat(d.revenue) || 0
      row[`${d.product}_ecpm`] = parseFloat(d.ecpm) || 0
      row[`${d.product}_requests`] = parseInt(d.requests) || 0
      row[`${d.product}_paid`] = parseInt(d.paid) || 0
    })
    return Array.from(productTrendMap.values()).sort((a, b) => {
      return new Date(a.rawDate).getTime() - new Date(b.rawDate).getTime()
    })
  }, [data?.productTrend])

  // Get raw product trend for line generation (MEMOIZED)
  const productTrendRaw = useMemo(() => data?.productTrend || [], [data?.productTrend])

  // Format product trend data with fill rate calculation (MEMOIZED)
  const productTrendDataWithFillRate = useMemo(() => {
    return productTrendData.map(row => {
      const newRow = { ...row }
      // Calculate fill rate for each product (multiply by 100 for percentage display)
      Array.from(new Set(productTrendRaw.map((d: any) => d.product))).forEach((product: any) => {
        const requests = row[`${product}_requests`] || 0
        const paid = row[`${product}_paid`] || 0
        newRow[`${product}_fill_rate`] = requests > 0 ? ((paid / requests) * 100) : 0
      })
      return newRow
    })
  }, [productTrendData, productTrendRaw])

  // Format zone monitoring time series - use lazy-loaded data (MEMOIZED)
  const zoneMonitoringTimeSeries = useMemo(() => {
    return zoneMonitoringData.map((d: any) => {
      const rawDate = d.date.value || d.date
      return {
        date: new Date(rawDate).toLocaleDateString('en-US', { month: 'short', day: 'numeric' }),
        rawDate: rawDate, // Keep ISO format for cross-filtering
        zid: parseInt(d.zid) || 0,
        zonename: d.zonename || '',
        product: d.product || '',
        req: parseInt(d.req) || 0,
        fill_rate: parseFloat(d.fill_rate) || 0,
        request_CPM: parseFloat(d.request_CPM) || 0,
        rev: parseFloat(d.rev) || 0,
        profit: parseFloat(d.profit) || 0,
      }
    })
  }, [zoneMonitoringData])

  return (
    <div
      className="space-y-0"
      style={{
        backgroundColor: '#FAFAFA',
        minHeight: '100vh',
        minWidth: 0,
        width: '100%',
        maxWidth: '100%',
        boxSizing: 'border-box',
        overflow: 'hidden'
      }}
    >
      {/* Page Title with Export */}
      <PageHeader title="Business Health Dashboard" contentRef={contentRef} />

      {/* Cross-Filter Chips */}
      <CrossFilterChips />

      {/* Filter Panel */}
      {showMetadataError ? (
        <div className="p-6">
          <div className="rounded-lg border border-red-200 bg-red-50 p-4">
            <h3 className="font-semibold text-red-900 mb-2">Failed to Load Filters</h3>
            <p className="text-red-700 text-sm mb-4">{metadataError}</p>
            <button
              onClick={() => window.location.reload()}
              className="px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700 text-sm font-medium"
            >
              Retry
            </button>
          </div>
        </div>
      ) : metadataLoading ? (
        <FilterPanelSkeleton />
      ) : (
        <FilterPanel
          filters={filterConfig}
          onFilterChange={setCurrentFilters}
          isLoading={loading}
        />
      )}

      {/* Content */}
      <div ref={contentRef} className="max-w-7xl mx-auto px-4 sm:px-6 md:px-8 lg:px-10 pt-6 space-y-6 md:space-y-8" style={{ maxWidth: '100%', boxSizing: 'border-box' }}>
        {/* Top Metrics Row */}
        {loading && !data ? (
          <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-4 md:gap-6">
            {Array.from({ length: 5 }).map((_, i) => (
              <MetricCardSkeleton key={i} />
            ))}
          </div>
        ) : data ? (
          <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-4 md:gap-6">
            <MetricCard
              label="Rev"
              value={Math.round(metrics.total_revenue || 0).toLocaleString()}
              unit=""
            />
            <MetricCard
              label="Profit"
              value={Math.round(metrics.total_profit || 0).toLocaleString()}
              unit=""
            />
            <MetricCard
              label="Paid"
              value={(parseFloat(metrics.total_paid) / 1_000_000 || 0).toFixed(1)}
              unit="M"
            />
            <MetricCard
              label="Req"
              value={(parseFloat(metrics.total_requests) / 1_000_000 || 0).toFixed(1)}
              unit="M"
            />
            <MetricCard
              label="Profit rate"
              value={`${data?.profitRate || 0}`}
              unit="%"
            />
          </div>
        ) : null}

        {/* Revenue & Profit Over Time */}
        {loading && !data ? (
          <ChartSkeleton />
        ) : timeSeries.length > 0 ? (
          <TimeSeriesChart
            title="Revenue & Profit Over Time"
            data={timeSeries}
            lines={[
              { dataKey: 'revenue', name: 'rev', color: colors.main },
              { dataKey: 'profit', name: 'profit', color: colors.accent },
            ]}
            height={300}
          />
        ) : null}

        {/* List of PID Tables - 2 columns layout */}
        {loading && !data ? (
          <div className="grid grid-cols-1 lg:grid-cols-2 gap-3 md:gap-4 lg:gap-6">
            <TableSkeleton rows={10} />
            <TableSkeleton rows={10} />
          </div>
        ) : (
          <div className="grid grid-cols-1 lg:grid-cols-2 gap-3 md:gap-4 lg:gap-6 [&>*]:min-w-0">
            {/* List of PID Table with Lazy Loading */}
            <LazyDataTable
              title="List of PID"
              columns={[
                { key: 'pid', label: 'pid', width: '15%' },
                { key: 'pubname', label: 'pubname', width: '45%' },
                { key: 'rev', label: 'rev', width: '20%' },
                { key: 'profit', label: 'profit', width: '20%' },
              ]}
              data={listOfPidData}
              crossFilterColumns={['pid', 'pubname']}
              onLoadMore={loadMoreListOfPid}
              hasMore={listOfPidOffset < listOfPidTotal}
              isLoading={listOfPidLoading}
              totalCount={listOfPidTotal}
            />

            {/* List of PID by Date Table with Lazy Loading */}
            <LazyDataTable
              title="List of PID by date"
              columns={[
                { key: 'date', label: 'date', width: '18%', format: (v) => new Date(v.value || v).toLocaleDateString() },
                { key: 'pid', label: 'pid', width: '12%' },
                { key: 'pubname', label: 'pubname', width: '40%' },
                { key: 'rev', label: 'rev', width: '15%' },
                { key: 'profit', label: 'profit', width: '15%' },
              ]}
              data={listOfPidByDateData}
              crossFilterColumns={['date', 'pid', 'pubname']}
              onLoadMore={loadMoreListOfPidByDate}
              hasMore={listOfPidByDateOffset < listOfPidByDateTotal}
              isLoading={listOfPidByDateLoading}
              totalCount={listOfPidByDateTotal}
            />
          </div>
        )}

        {/* List of MID Tables - 2 columns layout */}
        {loading && !data ? (
          <div className="grid grid-cols-1 lg:grid-cols-2 gap-3 md:gap-4 lg:gap-6">
            <TableSkeleton rows={10} />
            <TableSkeleton rows={10} />
          </div>
        ) : (
          <div className="grid grid-cols-1 lg:grid-cols-2 gap-3 md:gap-4 lg:gap-6 [&>*]:min-w-0">
            {/* List of MID Table with Lazy Loading */}
            <LazyDataTable
              title="List of MID"
              columns={[
                { key: 'mid', label: 'mid', width: '15%' },
                { key: 'medianame', label: 'medianame', width: '45%' },
                { key: 'rev', label: 'rev', width: '20%' },
                { key: 'profit', label: 'profit', width: '20%' },
              ]}
              data={listOfMidData}
              crossFilterColumns={['mid', 'medianame']}
              onLoadMore={loadMoreListOfMid}
              hasMore={listOfMidOffset < listOfMidTotal}
              isLoading={listOfMidLoading}
              totalCount={listOfMidTotal}
            />

            {/* List of MID by Date Table with Lazy Loading */}
            <LazyDataTable
              title="List of MID by date"
              columns={[
                { key: 'date', label: 'date', width: '18%', format: (v) => new Date(v.value || v).toLocaleDateString() },
                { key: 'mid', label: 'mid', width: '12%' },
                { key: 'medianame', label: 'medianame', width: '40%' },
                { key: 'rev', label: 'rev', width: '15%' },
                { key: 'profit', label: 'profit', width: '15%' },
              ]}
              data={listOfMidByDateData}
              crossFilterColumns={['date', 'mid', 'medianame']}
              onLoadMore={loadMoreListOfMidByDate}
              hasMore={listOfMidByDateOffset < listOfMidByDateTotal}
              isLoading={listOfMidByDateLoading}
              totalCount={listOfMidByDateTotal}
            />
          </div>
        )}

        {/* Top Rankings - 2x2 Grid */}
        {loading && !data ? (
          <div className="grid grid-cols-1 xl:grid-cols-2 gap-4 md:gap-6 lg:gap-8">
            {Array.from({ length: 4 }).map((_, i) => (
              <ChartSkeleton key={i} />
            ))}
          </div>
        ) : data ? (
          <div className="grid grid-cols-1 xl:grid-cols-2 gap-4 md:gap-6 lg:gap-8">
            {data?.topPublishers && data.topPublishers.length > 0 && (
              <BarChartComponent
                title="Top 10 publishers by Revenue"
                data={data.topPublishers}
                barDataKey="revenue"
                barName="rev"
                barColor={colors.main}
                xAxisDataKey="pubname"
                height={300}
              />
            )}

            {data?.topMedia && data.topMedia.length > 0 && (
              <BarChartComponent
                title="Top 10 media by Revenue"
                data={data.topMedia}
                barDataKey="revenue"
                barName="rev"
                barColor={colors.main}
                xAxisDataKey="medianame"
                height={300}
              />
            )}

            {data?.topZones && data.topZones.length > 0 && (
              <BarChartComponent
                title="Top 10 zones by Revenue"
                data={data.topZones}
                barDataKey="revenue"
                barName="rev"
                barColor={colors.main}
                xAxisDataKey="zonename"
                height={300}
              />
            )}

            {data?.topEcpm && data.topEcpm.length > 0 && (
              <BarChartComponent
                title="Top 10 zones by ecpm"
                data={data.topEcpm}
                barDataKey="ecpm"
                barName="request_CPM"
                barColor={colors.main}
                xAxisDataKey="zonename"
                height={300}
              />
            )}
          </div>
        ) : null}

        {/* Zone Monitoring Table */}
        {loading && !data ? (
          <TableSkeleton rows={10} />
        ) : data?.zoneMonitoring && data.zoneMonitoring.length > 0 ? (
          <DataTable
            title="Zone monitoring"
            columns={[
              { key: 'zid', label: 'zid' },
              { key: 'zonename', label: 'zonename' },
              { key: 'product', label: 'product' },
              { key: 'req', label: 'req', format: (v) => parseInt(v).toLocaleString() },
              { key: 'fill_rate', label: 'fill rate', format: (v) => `${Math.round(v * 100)}%` },
              { key: 'request_CPM', label: 'request_CPM' },
              { key: 'rev', label: 'rev' },
              { key: 'profit', label: 'profit' },
            ]}
            data={data.zoneMonitoring}
            crossFilterColumns={['zid', 'zonename', 'product']}
          />
        ) : null}

        {/* Zone Monitoring by Date Table with Lazy Loading */}
        {loading && !data ? (
          <TableSkeleton rows={10} />
        ) : (
          <LazyDataTable
            title="Zone monitoring by date"
            columns={[
              { key: 'date', label: 'date', width: '18%', format: (v) => new Date(v.value || v).toLocaleDateString() },
              { key: 'zid', label: 'zid', width: '7%' },
              { key: 'zonename', label: 'zonename', width: '16%' },
              { key: 'product', label: 'product', width: '11%' },
              { key: 'req', label: 'req', width: '10%', format: (v) => parseInt(v).toLocaleString() },
              { key: 'fill_rate', label: 'fill rate', width: '9%', format: (v) => `${Math.round(v * 100)}%` },
              { key: 'request_CPM', label: 'request_CPM', width: '11%' },
              { key: 'rev', label: 'rev', width: '9%' },
              { key: 'profit', label: 'profit', width: '9%' },
            ]}
            data={zoneMonitoringTimeSeries}
            crossFilterColumns={['date', 'zid', 'zonename', 'product']}
            onLoadMore={loadMoreZoneMonitoring}
            hasMore={zoneMonitoringOffset < zoneMonitoringTotal}
            isLoading={zoneMonitoringLoading}
            totalCount={zoneMonitoringTotal}
          />
        )}

        {/* Product-Level Trend */}
        {loading && !data ? (
          <ChartSkeleton />
        ) : productTrendData.length > 0 ? (
          <div className="space-y-4">
            {/* Metric Selector */}
            <div className="flex items-center gap-4 px-4">
              <span className="text-sm font-medium text-gray-700">Select Metric:</span>
              <ToggleGroup
                type="single"
                value={selectedMetric}
                onValueChange={(value) => {
                  if (value) setSelectedMetric(value as 'revenue' | 'profit' | 'requests' | 'paid' | 'ecpm' | 'fill_rate')
                }}
              >
                <ToggleGroupItem value="revenue">Revenue</ToggleGroupItem>
                <ToggleGroupItem value="profit">Profit</ToggleGroupItem>
                <ToggleGroupItem value="requests">Requests</ToggleGroupItem>
                <ToggleGroupItem value="paid">Paid</ToggleGroupItem>
                <ToggleGroupItem value="ecpm">eCPM</ToggleGroupItem>
                <ToggleGroupItem value="fill_rate">Fill Rate</ToggleGroupItem>
              </ToggleGroup>
            </div>

            {/* Chart Rendering */}
            {selectedMetric === 'fill_rate' ? (
              <TimeSeriesChart
                title="Product-Level Trend: Fill Rate Over Time"
                data={productTrendDataWithFillRate}
                lines={Array.from(new Set(productTrendRaw.map((d: any) => d.product))).map((product: any, idx: number) => ({
                  dataKey: `${product}_fill_rate`,
                  name: product,
                  color: ['#8b5cf6', '#ec4899', '#f59e0b', '#3b82f6', '#10b981'][idx % 5],
                }))}
                height={300}
                customYAxisFormatter={(value) => `${Math.round(value)}%`}
                customTooltipFormatter={(value, name) => [`${value.toFixed(2)}%`, name]}
              />
            ) : (
              <TimeSeriesChart
                title={`Product-Level Trend Over Time (${selectedMetric})`}
                data={productTrendData}
                lines={Array.from(new Set(productTrendRaw.map((d: any) => d.product))).map((product: any, idx: number) => ({
                  dataKey: `${product}_${selectedMetric}`,
                  name: product,
                  color: ['#8b5cf6', '#ec4899', '#f59e0b', '#3b82f6', '#10b981'][idx % 5],
                }))}
                height={300}
              />
            )}
          </div>
        ) : null}
      </div>
    </div>
  )
}
